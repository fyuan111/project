#!/usr/bin/env python3
"""
FML Message Generator
从 .msg 文件生成 C/C++ 头文件

用法:
    python3 msg_gen.py <msg_dir> <output_dir>

示例:
    python3 msg_gen.py ../msg ../build/msg
"""

import os
import sys
import re
from pathlib import Path

# 类型映射: msg类型 -> C类型
TYPE_MAP = {
    'uint8':   'uint8_t',
    'uint16':  'uint16_t',
    'uint32':  'uint32_t',
    'uint64':  'uint64_t',
    'int8':    'int8_t',
    'int16':   'int16_t',
    'int32':   'int32_t',
    'int64':   'int64_t',
    'float':   'float',
    'float32': 'float',
    'float64': 'double',
    'double':  'double',
    'bool':    'bool',
    'char':    'char',
}

def parse_msg_file(filepath):
    """解析 .msg 文件,返回字段列表"""
    fields = []
    constants = []

    with open(filepath, 'r') as f:
        for line in f:
            line = line.strip()

            # 跳过空行和注释
            if not line or line.startswith('#'):
                continue

            # 提取注释
            comment = ''
            if '#' in line:
                line, comment = line.split('#', 1)
                line = line.strip()
                comment = comment.strip()

            # 解析常量定义: uint8 NAME = 0
            if '=' in line:
                match = re.match(r'(\w+)\s+(\w+)\s*=\s*(.+)', line)
                if match:
                    ctype, name, value = match.groups()
                    constants.append({
                        'type': TYPE_MAP.get(ctype, ctype),
                        'name': name,
                        'value': value.strip(),
                        'comment': comment
                    })
                continue

            # 解析字段: type name 或 type name[size]
            match = re.match(r'(\w+)\s+(\w+)(\[(\d+)\])?', line)
            if match:
                msg_type = match.group(1)
                name = match.group(2)
                array_size = match.group(4)

                c_type = TYPE_MAP.get(msg_type, msg_type)

                fields.append({
                    'type': c_type,
                    'name': name,
                    'array_size': array_size,
                    'comment': comment
                })

    return fields, constants

def generate_header(msg_name, fields, constants):
    """生成头文件内容"""
    struct_name = f"{msg_name}_s"
    topic_name = msg_name

    lines = []
    lines.append("/* Auto-generated by msg_gen.py - DO NOT EDIT */")
    lines.append("")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("#include <stdbool.h>")
    lines.append("")

    # 生成常量定义
    if constants:
        lines.append(f"/* Constants for {msg_name} */")
        for const in constants:
            comment = f"  /* {const['comment']} */" if const['comment'] else ""
            lines.append(f"#define {msg_name.upper()}_{const['name']} {const['value']}{comment}")
        lines.append("")

    # 生成结构体
    lines.append(f"struct {struct_name} {{")
    lines.append("    uint64_t timestamp;  /* 时间戳 (us) */")

    for field in fields:
        comment = f"  /* {field['comment']} */" if field['comment'] else ""
        if field['array_size']:
            lines.append(f"    {field['type']} {field['name']}[{field['array_size']}];{comment}")
        else:
            lines.append(f"    {field['type']} {field['name']};{comment}")

    lines.append("};")
    lines.append("")

    # 生成话题宏
    lines.append(f"#define TOPIC_{msg_name.upper()}_NAME \"{topic_name}\"")
    lines.append(f"#define TOPIC_{msg_name.upper()}_SIZE sizeof(struct {struct_name})")
    lines.append("")

    return '\n'.join(lines)

def generate_registry(generated, output_path):
    """生成话题注册表头文件"""
    registry_file = output_path / "topic_registry.h"

    lines = []
    lines.append("/* Auto-generated by msg_gen.py - DO NOT EDIT */")
    lines.append("")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("#include <stddef.h>")
    lines.append("#include \"messages.h\"")
    lines.append("")
    lines.append("/* 话题注册表项 */")
    lines.append("struct topic_info {")
    lines.append("    const char *name;")
    lines.append("    size_t size;")
    lines.append("};")
    lines.append("")
    lines.append("/* 话题注册表 */")
    lines.append(f"#define TOPIC_COUNT {len(generated)}")
    lines.append("")
    lines.append("static const struct topic_info topic_registry[] = {")

    for name in sorted(generated):
        lines.append(f"    {{ TOPIC_{name.upper()}_NAME, TOPIC_{name.upper()}_SIZE }},")

    lines.append("};")
    lines.append("")
    lines.append("/* 注册所有话题到 IdcManager */")
    lines.append("#ifdef __cplusplus")
    lines.append("#include <idc/idcmanager.hpp>")
    lines.append("")
    lines.append("static inline void idc_register_all_topics(void) {")
    lines.append("    for (int i = 0; i < TOPIC_COUNT; i++) {")
    lines.append("        IdcManager::instance().advertise(topic_registry[i].name, topic_registry[i].size);")
    lines.append("    }")
    lines.append("}")
    lines.append("#endif /* __cplusplus */")
    lines.append("")

    with open(registry_file, 'w') as f:
        f.write('\n'.join(lines))

    print(f"  -> Generated: {registry_file}")

def process_msg_files(msg_dir, output_dir):
    """处理目录下所有 .msg 文件"""
    msg_path = Path(msg_dir)
    output_path = Path(output_dir)

    # 创建输出目录
    output_path.mkdir(parents=True, exist_ok=True)

    generated = []

    for msg_file in msg_path.glob('*.msg'):
        msg_name = msg_file.stem  # 文件名不带扩展名

        print(f"Processing: {msg_file.name}")

        fields, constants = parse_msg_file(msg_file)
        header_content = generate_header(msg_name, fields, constants)

        # 写入头文件
        output_file = output_path / f"{msg_name}.h"
        with open(output_file, 'w') as f:
            f.write(header_content)

        generated.append(msg_name)
        print(f"  -> Generated: {output_file}")

    # 生成 messages.h 总头文件
    if generated:
        all_header = output_path / "messages.h"
        with open(all_header, 'w') as f:
            f.write("/* Auto-generated by msg_gen.py - DO NOT EDIT */\n")
            f.write("#pragma once\n\n")
            for name in sorted(generated):
                f.write(f'#include "{name}.h"\n')
        print(f"  -> Generated: {all_header}")

        # 生成注册表
        generate_registry(generated, output_path)

    return generated

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <msg_dir> <output_dir>")
        print(f"Example: {sys.argv[0]} ../msg ../build/msg")
        sys.exit(1)

    msg_dir = sys.argv[1]
    output_dir = sys.argv[2]

    if not os.path.isdir(msg_dir):
        print(f"Error: msg directory '{msg_dir}' not found")
        sys.exit(1)

    print(f"FML Message Generator")
    print(f"  Input:  {msg_dir}")
    print(f"  Output: {output_dir}")
    print()

    generated = process_msg_files(msg_dir, output_dir)

    print()
    print(f"Generated {len(generated)} message(s)")

if __name__ == '__main__':
    main()
